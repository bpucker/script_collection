# script_collection
Collection of scripts to solve small bioinformatic challenges.


# identify_RBHs.py

Identification of Reciprocal Best BLAST Hits (RBHs) between to sets of sequences (protein/DNA). The scripts constructs BLAST databases and runs blastp/blastn in both directions. RBHs are identified and writen to a text file ('RBH_file.txt') in the specified output directory.

Requirements:

1) Python 2.7.x (other Python 2 versions should work as well)
2) BLAST (makeblastdb, blastn, and blastp should be in PATH)

Usage:

python identify_RBHs.py \
--input1 <FASTA_FILE_1> \
--input2 <FASTA_FILE2> \
--prefix <OUTPUT_DIRECTORY_NAME> \
--seq_type <prot|nucl> \
--cpu <NUMBER_OF_CPUs_TO_USE>


Suggested citation:

Pucker et al., 2016: 'A De Novo Genome Sequence Assembly of the Arabidopsis thaliana Accession Niederzenz-1 Displays Presence/Absence Variation and Strong Synteny'
http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0164321





# sort_contigs_on_ref.py

Whole Genome Shotgun (WGS) assembly contigs can be ordered and oriented based on an available reference sequence. This script does a placement of all given sequences based on the central position of their best BLASTn hit against the reference sequence. A new FASTA file is constructed, in which all seqeuences are saved under new systematic names (scaffold<running_number>). Association between old and new names is printed during this process and can easily be written into a documentation file.

Requirements:

1) Python 2.7.x (other Python 2 versions should work as well)
2) BLAST (makeblastdb and blastn should be in PATH)

Usage:

python sort_contigs_on_ref.py \
--contig_file <FULL_PATH_TO_FILE> \
--ref_file <FULL_PATH_TO_FILE> \
--output_dir <FULL_PATH_TO_DIR> > <DOCUMENTATION_FILE>

Suggested citation:

Pucker et al., 2016: 'A De Novo Genome Sequence Assembly of the Arabidopsis thaliana Accession Niederzenz-1 Displays Presence/Absence Variation and Strong Synteny'
http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0164321





# split_FASTQ.py

Splits FASTQ file with alternating mate1 and mate2 reads of paired-end sequencing into two separate files with mate1 and mate2, respectively. Can be applied after downloading FASTQ files from the SRA via webbrowser. New files will be placed next to the original file with '_1' and '_2' added to their file base name. This script can handle raw FASTQ files (.fastq) as well as gzip compressed files (.fastq.gz).

Requirements:

1) Python 2.7.x (other Python 2 versions should work as well)

Usage:

python split_FASTQ.py \
--in_file <FULL_PATH_TO_FILE>


Suggested citation:

this repository





# sort_vcf_by_fasta.py

A given VCF file is sorted based on the provided FASTA file. The chromosome order and numeric positions within the chromosome sequences are taken into account to adjust the VCF file. This can be helpful during variant calling with GATK.

Requirements:

1) Python 2.7.x (other Python 2 versions should work as well)

Usage:

python sort_vcf_by_fasta.py \
--vcf <FULL_PATH_TO_INPUT_VCF> \
--fasta <FULL_PATH_TO_INPUT_FASTA_FILE> \
--output <FULL_PATH_TO_OUTPUT_VCF_FILE>


Suggested citation:

this repository




# contig_stats.py
This script can be used to calculate some basic statistics and to remove short contigs after generating a de novo assembly. Contigs above the cutoff are written into a new FASTA file which is placed next to the original file. In addition, some statistics about his cleaned assembly are calculated and written into a separate text file. This script was tested on assemblies generated by CLC Genomics Workbench, SOAPdenovo2, and Trinity.

Requirements:

1) Python 2.7.x (other Python 2 versions should work as well)

Usage:

python contig_stats.py \
--input <FILENAME> \
--min_contig_len <MINIMLAL_CONTIG_LENGTH_TO_KEEP> [default=500]


Suggested citation:

Pucker et al., 2016: 'A De Novo Genome Sequence Assembly of the Arabidopsis thaliana Accession Niederzenz-1 Displays Presence/Absence Variation and Strong Synteny'
http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0164321



# grep_seqs_from_fastq.py
This script greps reads from a given FASTQ file if they match a provided sequence. It can be used to collect data for manual improvement of critical region in an assembly e.g. to extend contigs.


Requirements:

1) Python 2.7.x (other Python 2 versions should work as well)

Usage:

python grep_seqs_from_fastq.py \
--in <FULL_PATH_TO_FASTQ_FILE> \
--out <FULL_PATH_TO_OUTPUT_FILE> \
--seq <SEQUENCE_TO_FIND>

Suggested citation:

this repository


# candidate_gene_identification.py
This script can be used to identify candidate genes for complete pathways or gene families. A set of query protein sequences e.g. from different other species is needed for the search. Best candidates are first identified via BLASTp.

optional:

A phylogenetic tree is constructed to enable manual inspection of the results. This requires some external tools listed below.


Requirements:

1) Python 2.7.x (other Python 2 versions should work as well)
2) BLAST (blastp, makeblastdb should be in PATH)
optional:
3) MAFFT
4) pxclsq
5) FastTree

Usage:

python candidate_gene_identification.py \
--query <FULL_PATH_TO_QUERY_FILE> \
--pep <FULL_PATH_TO_SUBJECT_PEPTIDE_FILE> \
--prefix <FULL_PATH_TO_OUTPUT_DIRECTORY>


Suggested citation:

this repository



# get_reads_from_bam.py
This script can be used to extract paired-end reads after mapping to a reference sequence. An additional length filter can be applied to extract only read paires in which both mates have a sufficient length.



Requirements:

1) Python 2.7.x (other Python 2 versions should work as well)
2) samtools
3) bedtools

Usage:

python get_reads_from_bam.py \
--bam <FULL_PATH_TO_BAM> \
--out <FULL_PATH_TO_OUTPUT_DIR>

optional:

--min_len <MIN_READ_LENGTH>\n


Suggested citation:

this repository




# FASTQ_stats.py
This script calculates some basic statistics about a given FASTQ file or all FASTQ files in a given directory.


Requirements:

1) Python 2.7.x (other Python 2 versions should work as well)

Usage:

python FASTQ_stats.py \
--in_file <FULL_PATH_TO_FASTQ_FILE> |	--in_dir <FULL_PATH_TO_DIRECTORY>


Suggested citation:

this repository




# map_assembly_against_ref.py
This script maps all contigs of a de novo genome sequence assembly against a reference sequence. The coverage if illustrated to enable the identification of large scale presence/absence variations.


Requirements:

1) Python 2.7.x (other Python 2 versions should work as well) including matplotlib library
2) BLAST (blastn, makeblastdb should be in PATH)

Usage:

python dot_plot_heatmap.py \
--in <FULL_PATH_TO_ASSEMBLY_FILE> \
--ref <FULL_PATH_TO_REFERENCE_SEQUENCE> \
--out <FULL_PATH_TO_OUTPUT_DIRECTORY>


Suggested citation:

this repository






# combine_count_tables.py
This script combines all count tables given in the provided folders. It is assumed that these count tables were generated by featureCounts on the gene level. Multiple folder names can be provided separated by comma. The gene names in all count tables need to match. Raw counts and TPMs (=tags per million assigned tags) can be calculated independent of any annotation. The calculation of FPKMs is based on information about total exon length of a gene. GFF3 annotation is used for this step. The current versions assumes that the GFF3 file was downloaded from the NCBI and contains gene, transcript, and exon features. Overlapping exon features of different transcripts are merged to get the final exon length within a gene.


Requirements:

1) Python 2.7.x (other Python 2 versions should work as well)

Usage:

python combine_count_tables.py \
--in <FULL_PATH_INPUT_FILE(S)> (multiple paths can be provided comma-separated) \
--gff <FULL_PATH_TO_GFF3_FILE> \
--out <FULL_PATH_TO_OUTPUT_FILE>


Suggested citation:

this repository



# find_housekeeping_genes.py
This script identifies genes with very small variation in expression across multiple samples. Suche genes could be used as reference genes for qRT-PCR experiments. The gene expression file used as input should be in the output format of combine_count_tables.py: header line with different samples names, one row per gene starting with the gene name followed by expression values of the different samples. An annotation file can be provided to add a functional description to each gene in the output file.


Requirements:

1) Python 2.7.x (other Python 2 versions should work as well)

Usage:

python find_housekeeping_genes.py \
--in <FULL_PATH_TO_EXPRESSION_FILE> \
--out <FULL_PATH__TO_OUTPUT_FILE>

optional:
--anno <FULL_PATH__TO_ANNOTATION_FILE> \
--cutoff <MINIMAL_EXPRESSION_PER_SAMPLE(INTEGER)>


Suggested citation:

this repository



# analyze_codon_usage.py
This script analyzes the codon usage of a species based on provided protein coding sequences. Gene expression values can be included in this calculation if available. The format of a gene expression file should match the output of combine_count_tables.py: header line with different samples names, one row per gene starting with the gene name followed by expression values of the different samples.


Requirements:

1) Python 2.7.x (other Python 2 versions should work as well) including matplotlib library

Usage:

python analyze_codon_usage.py \
--in <FULL_PATH_TO_INPUT_FILE> \
--out<FULL_PATH_TO_OUTPUT_FILE>

optional:
--exp <FULL_PATH_TO_EXPRESSION_FILE>


Suggested citation:

this repository



# get_translation_bottlenecks.py
This script analyzes given protein coding sequences for condons with a rare frequency. Figures are constructed per sequence to indicate which codons could slow the translation down. There are checks to exclude sequences with ambiguity characters (Ns) as well as for the sequence length (multiple of 3).


Requirements:

1) Python 2.7.x (other Python 2 versions should work as well) including matplotlib library

Usage:

python get_translational_bottlenecks.py \
--in <FULL_PATH_TO_INPUT_FILE> \
--codon <FULL_PATH_TO_CODON_USAGE_TABLE> \
--out <FULL_PATH_TO_OUTPUT_DIRECTORY>


Suggested citation:

this repository



# construct_coverage_file.py
This script calculates the coverage per position based on a given BAM file. It can be used as preprocessing for the identificaiton of zero coverage regions (ZCRs) e.g. caused by presence/absence variations or for the investigation of copy number variations (CNVs).


Requirements:

1) Python 2.7.x (other Python 2 versions should work as well)
2) samtools
3) bedtools

Usage:

python construct_coverage_file.py \
--in <BAM_FILE> \
--out <OUTPUT_FILE> \

optional
--bam_is_sorted <PREVENTS_EXTRA_SORTING_OF_BAM_FILE>


Suggested citation:

this repository
